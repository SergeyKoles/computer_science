package yandexChampionship;

/**
 * C. Стоянка запрещена
 *
 * Все языки	Python 3.7.3	Python 2.7
 * Ограничение времени	1 секунда	10 секунд	10 секунд
 * Ограничение памяти	256Mb	256Mb	256Mb
 * Ввод	стандартный ввод или input.txt
 * Вывод	стандартный вывод или output.txt
 * Описание
 * В одном городе запретили машинам останавливаться, кроме как для посадки пасажира.
 * А пассажир не согласен ждать больше 3 минут.
 * В этом городе пешеход заказывает такси в точку X и указывает интервал в 180 секунд.
 * Водитель должен приехать ровно в этот интервал. Если приехать раньше, то ожидать пассажира будет нельзя.
 * Если приехать слишком поздно, то разозленный пассажир отменит заказ.
 *
 * Из-за подобных ограничений в этом городе осталось всего Z водителей,
 * каждый из которых в момент старта задачи находится в какой-то вершине графа дорожного движения.
 * Система управления должна назначить наилучшего водителя из тех, которые успеют приехать в указанный интервал.
 * Наилучшим водителем считается тот, который приедет на заказ максимально близко к началу интервала.
 * Если таких водителей несколько, то любой из них.
 *
 * Нужно для каждого водителя определить, успевает ли он приехать в указанный интервал, и если да -
 * то к какому самому раннему моменту времени в указанном интервале он может приехать.
 *
 * Формальное описание
 * Дано:
 * Ориентированный граф G с N вершинами и K ребрами, вершины пронумерованы от 0 до N-1, 0 ≤ N ≤ 104, 0 ≤ K ≤ 104.
 * Каждому ребру соответствует время поездки в нем - целое число W, 10 ≤ W ≤ 104.
 * Позиция заказа на графе IDtarget
 * Z позиций водителей на графе IDsourcez, 1 ≤ Z ≤ 104
 * Время t0, 0 ≤ t0 ≤ 600 - целое число
 * Надо для каждого водителя найти такоe t_min что:
 *
 * существует такой маршрут от IDsourcez водителя к IDtarget, что водитель приезжает в tmin
 * tmin ∈ [t0;t0+180]
 * и это самый ранний возможный tmin : tmin ≤ ti для любого ti, удовлетворяющего пунктам 1 и 2;
 * Или убедиться, что такого tmin не существует
 * Формат ввода
 * Граф задается в виде троек вершина-начало вершина-конец время-проезда
 *
 * Входные данные, каждый пункт на своей строке
 *
 * K - число ребер
 * K троек ID ID Weight - начальная вершина ребра, конечная вершина ребра, за сколько машина проезжает ребро.
 * IDtarget t0 - вершина заказа [пробел] начало диапазона, когда надо приехать
 * Z - кол-во водителей
 * (Z раз) IDz вершина следующего водителя
 * Формат вывода
 * Для каждого водителя в том же порядке, что они пришли на вход,
 * распечатать на отдельной строке вычисленное tmin или -1, если такого tmin не существует.
 *
 * Пример 1
 * Ввод	Вывод
 * 2
 * 0 1 10
 * 2 3 10
 * 3 0
 * 1
 * 0
 *
 * -1
 * Пример 2
 * Ввод	Вывод
 * 2
 * 0 1 10
 * 2 3 10
 * 1 0
 * 1
 * 0
 *
 * 10
 * Пример 3
 * Ввод	Вывод
 * 1
 * 0 1 10
 * 1 100
 * 1
 * 0
 *
 * -1
 * Примечания
 * Из вершины A в вершину Б могут идти несколько ребер, в т.ч. с одинаковым весом.
 * Допускаются ребра из A в A
 * Допускается существование одновременно ребер (А->Б) и (Б->А) (циклы длиной 2)
 */
public class NoParking {
}
